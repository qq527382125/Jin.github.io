<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F28%2Ftampermonkey%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[TampermonkeyTampermonkey是浏览器的一大神器，可以在里面编写javascript脚本，配合Tampermonkey自身的语法，为所匹配的网站添加自己的功能。本教程展示微博视频下载的脚本。 了解Tampermonkey为浏览器安装好Tampermonkey插件后,选择添加新脚本,生成脚本文件如下: // ==UserScript== // @name New Userscript // @namespace http://tampermonkey.net/ // @version 0.1 // @description try to take over the world! // @author You // @match http://blog.csdn.net/ // @grant none // ==/UserScript== (function() { 'use strict'; // Your code here... })(); 在生成的代码中,@math 写的是脚本生效的网址,为了使脚本对整个网站都生效可以使用通配符,也就是号eg:@match http://www.xxxx.com/为了方便操作页面元素,可以引用jQuery框架,添加代码 // @require http://code.jquery.com/jquery-1.11.0.min.js 之后在网页下写的脚本都将生效 元数据块元数据块是描述脚本的一个用户脚本部分。它通常包含脚本名称，命名空间，描述和包含和排除规则。元数据块出现在JavaScript行注释中，可能会出现在脚本内的任何位置， 但通常靠近文件的顶部。如果脚本没有声明@grant，那么Greasemonkey将自动检测脚本用了哪些API（目前自动检测的方法就是简单地看脚本中有没有出现这些API的名字，哪怕注释掉没运行的也算） 键 示例 备注 @name @name 脚本名称 脚本的名称。该项将显示在页面的标题以及链接内容，必填项。 @description @description 脚本功能描述 脚本功能的描述，显示在脚本标题下面，必填项。 @namespace @namespace 及 @name 这两个属性将帮助用户脚本管理器判断是否已安 装该脚本。 @version @version 0.0.1 脚本的版本标记将使用 Mozilla 版本格式 并显示于脚本的简介页面，必填 项。 @include@exclude@match @match ://www.52pojie.cn/ 描述脚本将执行的页面。该列表会被分析并展示到脚本的简介页面，以及 用于脚本分类。 @require @require http://cdn.bootcss.com/jquery.min.js 引用外部脚本到您的脚本 @updateURL@installURL, @downloadURL 告知用户脚本管理器应该在哪个地址获取脚本更新。 @license 脚本所使用的许可协议名称或地址，该协议需包含用户是否允许二次分发 或修改 脚本的权利。不提供许可协议则表示用户仅允许个人使用且不得 二次分发；该协 议将在脚本的简介页面显示。 @supportURL 用户可获得该脚本技术支持的链接地址 (如：错误反馈系统、论坛、电子 邮件)，该链接将显示在脚本的反馈页面。 @contributionURL 用于捐赠脚本作者的链接，该链接将显示在脚本的反馈页面。 @contributionAmount 建议捐赠金额，请配合 @contributionURL 使用。 @compatible 标记此脚本与某个浏览器兼容，兼容性信息将显示在脚本的简介页面上。 @incompatible 标记此脚本与某个浏览器不兼容，兼容性信息将显示在脚本的简介页面 上。 编写微博视频下载教程微博的视频在video中有视频直链,可以获取video的src属性,然后在页面上添加一个下载按钮,就可以直接下载视频资源.在@math后跟上*://weibo.com/tv/v/*,让脚本在有微博视频的地址生效. @require后跟上http://cdn.bootcss.com/jquery/1.8.3/jquery.min.js 引入jq类库 在自执行匿名函数中写上需要执行的脚本代码.让网址自动执行. (function () { 'use strict'; })(); 第一步:创建一个下载弹出框与获取文件名的工具对象. var videoTool ={ getFileName: function (url, rule_start, rule_end) { var start = url.lastIndexOf(rule_start) + 1;//参数首字母在url字符串中的位置. var end = url.lastIndexOf(rule_end); return url.substring(start,end); }, //弹出下载框 download: function (videoUrl, name){ var content = "file content!"; var data = new Blob([content],{ type: "text/plain;charset=UTF-8" });//创建一个blob对象 var downloadURL = window.URL.creatObjectURL(data);//创建一个URL对象 var anchor = document.creatElement("a"); //创建a标签DOM元素 anchor.href = videoUrl; anchor.download = name; anchor.click(); window.URL.revokeObjctURL(data); } }; 第二步,生成一个下载按钮,嵌入页面中 //调用了油猴脚本的API.与元数据块中的@grant值相对应，功能是生成一个style样式 GM_addStyle('#down_video_btn{color:#fa7d3c;}'); //视频下载按钮的html代码 var down_btn_html = '&lt;li>'; down_btn_html += '&lt;a href="javascript:void(0);" id="down_video_btn" class="S_txt2" title="视频下载">'; down_btn_html += '&lt;span class="pos">'; down_btn_html += '&lt;span class="line S_line1" node-type="comment_btn_text">'; down_btn_html += '&lt;span>'; down_btn_html += '&lt;em class="W_ficon ficon_video_v2 S_ficon">i&lt;/em>'; down_btn_html += '&lt;em>视频下载&lt;/em>'; down_btn_html += '&lt;/span>'; down_btn_html += '&lt;/span>'; down_btn_html += '&lt;/span>'; down_btn_html += ' &lt;span class="arrow">&lt;span class="W_arrow_bor W_arrow_bor_t">&lt;i class="S_line1">&lt;/i>&lt;em class="S_bg1_br">&lt;/em>&lt;/span>&lt;/span>'; down_btn_html += ' &lt;/li>'; //将以上拼接的html代码插入到网页里的ul标签中 var ul_tag = $("div.WB_handle>ul"); if (ul_tag) { ul_tag.removeClass("WB_row_r3").addClass("WB_row_r4").append(down_btn_html);//ul_tag DOM元素结尾加上down_btn_html 元素. } 最后一步 获取播放器(video)对象中的视频地址,并编写下载按钮的单击事件. $(function () { //获取播放器（video）对象 var video = $("video"); var video_url = null; if (video) { video_url = video.attr("src"); //获取视频链接地址 } //执行下载按钮的单击事件并调用下载函数 $("#down_video_btn").click(function () { if (video_url) { videoTool.download(video_url, videoTool.getFileName(video_url, "/", "?")); } }); });//download属性，只要有这个属性，点击这个链接时浏览器就不在打开链接指向的文件，而是改为下载 完整代码 // ==UserScript== // @icon http://weibo.com/favicon.ico // @name 微博视频下载助手 // @namespace http://weibo.com // @author jin // @description 下载微博视频 // @match *://weibo.com/tv/v/* // @require http://cdn.bootcss.com/jquery/1.8.3/jquery.min.js // @version 0.0.1 // @grant GM_addStyle // ==/UserScript== (function () { 'use strict'; //与元数据块中的@grant值相对应，功能是生成一个style样式 GM_addStyle('#down_video_btn{color:#fa7d3c;}'); //视频下载按钮的html代码 var down_btn_html = '&lt;li>'; down_btn_html += '&lt;a href="javascript:void(0);" id="down_video_btn" class="S_txt2" title="视频下载">'; down_btn_html += '&lt;span class="pos">'; down_btn_html += '&lt;span class="line S_line1" node-type="comment_btn_text">'; down_btn_html += '&lt;span>'; down_btn_html += '&lt;em class="W_ficon ficon_video_v2 S_ficon">i&lt;/em>'; down_btn_html += '&lt;em>视频下载&lt;/em>'; down_btn_html += '&lt;/span>'; down_btn_html += '&lt;/span>'; down_btn_html += '&lt;/span>'; down_btn_html += ' &lt;span class="arrow">&lt;span class="W_arrow_bor W_arrow_bor_t">&lt;i class="S_line1">&lt;/i>&lt;em class="S_bg1_br">&lt;/em>&lt;/span>&lt;/span>'; down_btn_html += ' &lt;/li>'; //将以上拼接的html代码插入到网页里的ul标签中 var ul_tag = $("div.WB_handle>ul"); if (ul_tag) { ul_tag.removeClass("WB_row_r3").addClass("WB_row_r4").append(down_btn_html); } var videoTool = { //获取文件名 getFileName: function (url, rule_start, rule_end) { var start = url.lastIndexOf(rule_start) + 1; var end = url.lastIndexOf(rule_end); return url.substring(start, end); }, //弹出下载框 download: function (videoUrl, name) { var content = "file content!"; var data = new Blob([content], { type: "text/plain;charset=UTF-8" }); var downloadUrl = window.URL.createObjectURL(data); var anchor = document.createElement("a"); anchor.href = videoUrl; anchor.download = name; anchor.click(); window.URL.revokeObjectURL(data); } }; $(function () { //获取播放器（video）对象 var video = $("video"); var video_url = null; if (video) { video_url = video.attr("src"); //获取视频链接地址 } //执行下载按钮的单击事件并调用下载函数 $("#down_video_btn").click(function () { if (video_url) { videoTool.download(video_url, videoTool.getFileName(video_url, "/", "?")); } }); }); })();]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F04%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%9F%E5%88%97%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数据结构是指互相之间存在一种或多种特定关系的数据元素的集合 什么是数据结构?数据结构是指互相之间存在一种或多种特定关系的数据元素的集合 队列先进先出 FIFO:first in first out普通队列:有两种情况第一种:售票员不动,第一个人买到票走后,后面一个人向前走,变成队列头,但是效率低第二种:售票员一直向后走,但是前面的内存空间就被浪费了环形队列元素空间可以重复利用:因为一般的环形队列都是一个元素数固定的一个闭环，可以在环形队列初始化的时候分配好确定的内存空间，当进队或出队时只需要返回指定元素内存空间的地址即可，这些内存空间可以重复利用，避免频繁内存分配和释放的开销。 环形队列C++实现class MyQueue { public: MyQueue(int queueCapacity);//创建队列 virtual ~MyQueue();//销毁队列,析构函数 void ClearQueue();//清空队列 bool QueueEmpty() const;//判空队列 int QueueLength() const;//队列长度 bool Enqueue(int element);//新元素入队 bool DeQueue(int &element);//首元素出队 void QueueTraverse();//遍历队列 private: int *m_pQueue;//队列数组指针 int m_iQueueLen;//队列元素个数 int m_iQueueCapacity;//队列数组容量 }]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单验证]]></title>
    <url>%2F2018%2F04%2F24%2Fjs%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[javacript表单验证 知识点 js正则表达式 表单元素是事件 最简单的表单验证表单要放在标签对中 &lt;!-- &lt;br>是HTML写法。 &lt;br/>是XHTML1.1的写法，也是XML写法。 &lt;br />是XHTML为兼容HTML的写法，也是XML写法。--> &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>最简单表单HTML结构&lt;/title> &lt;/head> &lt;body> &lt;form method="post" action=""> 账号:&lt;input type="text" name="" />&lt;br/>&lt;br/> 密码:&lt;input type="password" name="" />&lt;br/>&lt;br/> 确认:&lt;input type="password" name="" />&lt;br/>&lt;br/> &lt;input type="submit" value="注册"> &lt;/form> &lt;/body> &lt;/html> 绑定验证功能为”注册”按钮绑定一个onclick事件属性,引用eg.regCheck() &lt;!--在HTML5规范中，script的type属性默认是text/javascript，所以可以省略；但是在HTML 4.01和XHTML 1.0规范中，type属性是必须的。--> &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>最简单表单HTML结构&lt;/title> &lt;/head> &lt;body> &lt;form method="post" action=""> 账号:&lt;input type="text" name="" />&lt;br />&lt;br /> 密码:&lt;input type="password" name="" />&lt;br />&lt;br /> 确认:&lt;input type="password" name="" />&lt;br />&lt;br /> &lt;input type="submit" value="注册" onclick="return eg.regCheck();"/> &lt;/form> &lt;script type="text/javascript"> var eg ={};//申明一个对象,当做命名空间使用,方便管理 eg.regCheck = function(){ } &lt;/script> &lt;/body> &lt;/html> 给表单添加验证功能让eg.regCheck()函数做些什么才是,比如获取用户输入的账号该怎么办?这时最好给input标签加个id属性,JS再通过这个指定的id去获取对应的信息,然后验证结果true或者false 涉及HTML DOM getElementById() 方法语法document.getElementById(id) getElementById() 方法可返回对拥有指定 ID 的第一个对象的引用。 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>最简单表单HTML结构&lt;/title> &lt;/head> &lt;body> &lt;form method="post" action=""> 账号:&lt;input type="text" name="" id="userid" />&lt;br />&lt;br /> 密码:&lt;input type="password" name="" id="userpwd"/>&lt;br />&lt;br /> 确认:&lt;input type="password" name="" id = "userpwd2"/>&lt;br />&lt;br /> &lt;input type="submit"value="注册"onclick="return eg.regCheck();"/> &lt;/form> &lt;script type="text/javascript"> var eg ={}; eg.$=function(id){ return document.getElementById(id); };//定义一个公共函数来获取指定id元素,减少代码量,提高代码复用率 eg.regCheck = function(){ var uid = eg.$("userid"); var upwd= eg.$("userpwd"); var upwd2= eg.$("userpwd2"); if(uid.value==''){ alert('账号不能为空'); return false; } if(upwd.value==''){ alert('密码不能为空'); return false; } if(upwd2.value != upwd.value){ alert('两次密码输入不相同'); return false; } return true; }; &lt;/script> &lt;/body> &lt;/html> onSubmit是表单上(也只能是表单)用的,提交表单前会触发onClick是按钮等控件上用的,用来触发点击事件.用作数据验证的时候,可以选择在submit按钮上的onclick中验证,可以在onsubmit中验证.但是从事件触发顺序上来说,onclick更早.顺序是:用户点击按钮-&gt;onclick-&gt;如果onclick返回有效或未处理onclick则提交表单-&gt;onsubmit-&gt;如果onsubmit未处理或返回true,则提交,否则取消提交.onsubmit中返回false会引起取消表单提交;onclick中返回false则会引起此次点击操作被判断为无效,则也就不会引起表单提交. 绑定验证的另一种方式除了把验证绑定在放在注册按钮的onclick事件属性里使用,还可以放到form标签的onsubmit事件属性,功能一样 &lt;form method="post" action="" onsubmit="return eg.regCheck();"> 账号:&lt;input type="text" name="" id="userid" />&lt;br />&lt;br /> 密码:&lt;input type="password" name="" id="userpwd"/>&lt;br />&lt;br /> 确认:&lt;input type="password" name="" id = "userpwd2"/>&lt;br />&lt;br /> &lt;input type="submit"value="注册"/> &lt;/form> 总结使用了eg这样的全局变量来存储自定义的各种方法,这成为==单全局变量==,这样做的目的是为了减少环境污染,著名的范例是jQuery库 处理表单问题增加简介字段,可以为空,但是最长不超过60个字符,同时要统计下,用户输入错误的次数,输入超过3次,就锁定注册按钮,然后要解锁才能重新使用 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>处理各种类型的表单元素&lt;/title> &lt;/head> &lt;body> &lt;form method="post" action="" onsubmit="return eg.regCheck();"> &lt;input type="hidden" name="" id ="errnum" value="0"/> 账号:&lt;input type="text" name="" id="userid" />&lt;br />&lt;br /> 密码:&lt;input type="password" name="" id="userpwd"/>&lt;br />&lt;br /> 确认:&lt;input type="password" name="" id = "userpwd2"/>&lt;br />&lt;br /> 简介:&lt;textarea name"" rows="4" cols="18" id="about">&lt;/textarea>&lt;br />&lt;br /> 性别&lt;input type="radio" name="sex" value="1"checked="checked"/>男&lt;input type="radio" name="sex" value="0"checked="checked"/>女&lt;br/>&lt;br/> &lt;input type="submit"value="注册" id="regBtn"/> &lt;input type="button"value="解锁" onclick="eg.unlock()" style="display:none;"id = "regUnlock"/> &lt;/form> &lt;script type="text/javascript"> var eg ={}; eg.$=function(id){ return document.getElementById(id); };//定义一个公共函数来获取指定id元素,减少代码量,提高代码复用率 eg.regCheck = function(){ var uid = eg.$("userid"); var upwd= eg.$("userpwd"); var upwd2= eg.$("userpwd2"); var about = eg.$("about"); if(uid.value==''){ alert('账号不能为空'); uid.focus(); eg.err(); return false; } if(upwd.value==''){ alert('密码不能为空'); eg.err(); return false; } if(upwd2.value != upwd.value){ alert('两次密码输入不相同'); eg.err(); return false; } if(about.value.length>60){ alert('简介太长!'); eg.err(); return false; } return true; }; //记录出错的错误次数 eg.err = function(){ var e1 = eg.$("errnum"); var old = e1.value; e1.value=parseInt(old)+1;//把字符串转换成整数+1,并保存起来 eg.lock();//检测是否应该锁定 }; //通过次数判定是否要锁定注册 eg.lock=function(){ var err = eg.$("errnum"); if(parseInt(err.value)>2){ eg.$("regBtn").disabled = true;//输入3次错误就锁定 eg.$("regUnlock").style.display="block";//同时显示解锁按钮 } }; eg.unlock=function(){ eg.$("regBtn").disabled = false; eg.$("regUnlock").style.display="none"; //元素所有样式都挂载到style属性下 }; &lt;/script> &lt;/body> &lt;/html> 记录js语句到出错的地方就停止了,后面的全部失效,按钮的disabled属性为true时会变成灰色,style.dispaly属性为none时隐藏,为block(展开)出现. 关于第8行的作用,在本文中是为了统计错误次数eg:&lt;input name=&#39;orderid&#39; type=hidden value=&quot;订单编号&quot;&gt;隐式文本域 主要是用来传递数据的，这数据恰巧又是你不想让客户端显示出来，你可以将数据在页面中隐藏这是隐藏表单，一般用来传递参数，而又不想显示在客户端。例如：客户在网站在购买产品，点击提交的时候，通常程序会自动生成一个产品的订单编号，用于后台操作或者其它。而我们通常是没必要把这个编号显示给客户看。 checkbox复选框,radio单选框,select下拉框 用正则表达式来验证输入规则​ 利用正则表达式可以校验复杂的格式要求 var email = eg.$("eamail"); if(!/^[A-Za-z\d]+[A-Za-z\d\-_\.]*@([A-Za-z\d]+][A-Za-z\d\-]*\.)[A-Za-z]{2,4}$/.test(eamail.value)){ alert('请输入正确的邮箱!'); eg.err(); return false; } 改善用户体验比如限制密码长度,要求字母数字组合,再如光标返回输入错误的地方,减少用户操作,基于这样的考虑,加入一些教会体验代码 //光标调到输入框代码 if(uid.value==''){ alert('账号不能为空'); uid.focus(); eg.err(); return false; }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome]]></title>
    <url>%2F2017%2F05%2F05%2Fchrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[使用好chrome是必不可少的 介绍chrome的一些不为人知的功能Chrome的开发者工具是个很强大的东西，相信程序员们都不会陌生，不过有些小功能可能并不为大众所知，所以，写下这篇文章罗列一下可能你所不知道的功能，有的功能可能会比较实用，有的则不一定，也欢迎大家补充交流。 话不多话，我们开始。 代码格式化 强制DOM状态 动画 直接编辑网页 网络限速 复制HTTP请求 抓个带手机的图 设置断点 关于Console中的技巧 关于console对象 关于快捷键 代码格式化有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 { } 标签，chrome会帮你给格式化掉。 强制DOM状态有些HTML的DOM是有状态的，比如&lt;a&gt; 标签，其会有 active，hover， focus，visited这些状态，有时候，我们的CSS会来定关不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 :hov 这个小按钮来强制这个DOM的状态。 动画现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的More Tools =&gt; Animations 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 25% 或10%），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。 直接编辑网页在你的 console 里 输入下面的命令： document.designMode = &quot;on&quot;11 于是你就可以直接修改网页上的内容了。 P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 clear() 或是 按Ctrl+L（Windows下），CMD + K (Mac下) 网络限速你可以设置你的网络的访问速度来模拟一个网络很慢的情况。 复制HTTP请求这个是我很喜欢 的一个功能，你可以在 network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： Copy =&gt; Copy as cURL，然后就可以到你的命令行下去 执行 curl 的命令了。这个可以很容易做一些自动化的测试。 友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。 抓个带手机的图这个可能有点无聊了，不过我觉得挺有意思的。 在device显示中，先选择一个手机，然后在右上角选 Show Device Frame，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。我抓的图如下（当然，不是所有的手机都有frame的） 设置断点除了给JavaScript的源代码上设置断点调试，你还可以： 给DOM设置断点选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项： 给XHR和Event Lisener设置断点在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下： 关于Console中的技巧DOM操作 chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。 你还可以使用像jQuery那样的语法来获得DOM对象，如：$(&quot;#mydiv&quot;) 你还可使用 $$(&quot;.class&quot;) 来选择所有满足条件的DOM对象。 你可以使用 getEventListeners($(&quot;selector&quot;)) 来查看某个DOM对象上的事件（如下图所示）。 你还可以使用 monitorEvents($(&quot;selector&quot;)) 来监控相关的事件。比如：monitorEvents(document.body, &quot;click&quot;); Console中的一些函数1.monitor函数使用 monitor函数来监控一函数，如下面的示例 2.copy函数inspect函数可以让你控制台跳到你需要查看的对象上。如：更多的函数请参数官方文档 – Using the Console / Command Line Reference Console的输出我们知道，除了console.log之外，还有console.debug，console.info，console.warn，console.error这些不同级别的输出。另外一个鲜为人知的功能是，console.log中，你还可以对输出的文本加上css的样式，如下所示： console.log(&quot;%c左耳朵&quot;, &quot;font-size:90px;color:#888&quot;)11 于是，你可以定义一些相关的log函数，如： console.todo = function( msg){ console.log( &#39;%c%s %s %s&#39;, &#39;font-size:20px; color:yellow; background-color: blue;&#39;, &#39;--&#39;, msg, &#39;--&#39;); } console.important = function( msg){ console.log( &#39;%c%s %s %s&#39;, &#39;font-size:20px; color:brown; font-weight: bold; text-decoration: underline;&#39;, &#39;--&#39;, msg, &#39;--&#39;); }123456123456 关于console.log中的格式化，你可以参看如下表格： 指示符 输出 %s 格式化输出一个字符串变量。 %i or %d 格式化输出一个整型变量的值。 %f 格式化输出一个浮点数变量的值。 %o 格式化输出一个DOM对象。 %O 格式化输出一个Javascript对象。 %c 为后面的字符串加上CSS样式 除了console.log打印js的数组，你还可以使用console.table来打印，如下所示： var pets = [ { animal: &#39;Horse&#39;, name: &#39;Pony&#39;, age: 23 }, { animal: &#39;Dog&#39;, name: &#39;Snoopy&#39;, age: 13 }, { animal: &#39;Cat&#39;, name: &#39;Tom&#39;, age: 18 }, { animal: &#39;Mouse&#39;, name: &#39;Jerry&#39;, age: 12} ]; console.table(pets)12345671234567 关于console对象 console对象除了上面的打日志的功能，其还有很多功能，比如： console.trace() 可以打出js的函数调用栈 console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。 console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。 console.count() 可以让你看到相同的日志当前被打印的次数。 console.assert(expression, object) 可以让你assert一个表达式 这些东西都可以看看Google的Console API的文档。 其实，还有很多东西，你可以参看Google的官方文档 – Chrome DevTools 关于快捷键点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 Shortcuts，你就可以看到所有的快捷键了 如果你知道更多，也欢迎补充！ （全文完）]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13个学习技巧]]></title>
    <url>%2F2017%2F05%2F05%2F13%E4%B8%AA%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[13个学习技巧 间歇重复 spaced repetiton为了最大化学习效率 进行时间短但频率高的学习 神经突触大部分在晚上睡觉的时候生长 这意味着有规律的学习 期间有睡眠先休息 这样更有效率 找到自己的风格 find your own style良好的睡眠 good night’s sleep睡觉与做梦是处理和存储新信息至关重要的部分 集中注意力 focus如果你易于拖延 也就是说你倾向于进行学习数学之类的困难任务转到轻松的事情如浏览网页 番茄工作法 pomodoro technique定时间25分钟时间 在此间完完全全专心于学习 当闹钟响起 放松5分钟 如果想继续 再定时开始 先做困难项 hard stuff first在早上有着最强的意志力 一旦你完成了困难的事情 你接下来一整天都会感觉更好 可能得到更多动力激发你完成其他的事项 运动 冥想 以及交谈 exercise meditate and converse有些活动被证实能让你的大脑增长 它们引起你的大脑中新的神经元的产生 从而增长其潜力 到不同的地方去 go places能创建对实物更深刻的记忆 更多的视觉线索进行记忆 认真看待乐趣 take fu seriously间隔再学习 space your studies按记忆曲线回顾 30%read 70% reciteinstant self-test额外的努力能制造更深刻的记忆痕迹 不要强迫 don’t force it]]></content>
      <categories>
        <category>习惯</category>
      </categories>
      <tags>
        <tag>habit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串查询]]></title>
    <url>%2F2017%2F05%2F05%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[简单的字符串查询算法 Problem StatementFor a given source string and a target string, you should output the first index(from 0) of target string in source string. If target does not exist in source, just return -1. ExampleIf source = &quot;source&quot; and target = &quot;target&quot;, return -1. If source = &quot;abcdabcdefg&quot; and target = &quot;bcd&quot;, return 1. 题解对于字符串查找问题,可以使用双重for循环解决,效率更高的则为KMP算法,双重 for 循环的使用较有讲究，因为这里需要考虑目标字符串比源字符串短的可能。对目标字符串的循环肯定是必要的，所以可以优化的地方就在于如何访问源字符串了。简单直观的解法是利用源字符串的长度作为 for 循环的截止索引，这种方法需要处理源字符串中剩余长度不足以匹配目标字符串的情况，而更为高效的方案则为仅遍历源字符串中有可能和目标字符串匹配的部分索引。 public class Solution { public int strStr(String haystack, String needle) { if (haystack == null &amp;&amp; needle == null) return 0; if (haystack == null) return -1; if (needle == null) return 0; for (int i = 0; i &lt; haystack.length() - needle.length() + 1; i++) { int j = 0; for (; j &lt; needle.length(); j++) { if (haystack.charAt(i+j) != needle.charAt(j)) break; } if (j == needle.length()) return i; } return -1; } } class Solution { public: int strStr(string haystack, string needle) { if (haystack.empty() && needle.empty()) return 0; if (haystack.empty()) return -1; if (needle.empty()) return 0; // in case of overflow for negative if (haystack.size() < needle.size()) return -1; for (int i = 0; i < haystack.size() - needle.size() + 1; i++) { string::size_type j = 0; for (; j < needle.size(); j++) { if (haystack[i + j] != needle[j]) break; } if (j == needle.size()) return i; } return -1; } };]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬盘]]></title>
    <url>%2F2017%2F05%2F05%2F%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[硬盘不是内存。硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。硬盘有固态硬盘（SSD 盘，新式硬盘）、机械硬盘（HDD 传统硬盘）、混合硬盘（HHD 一块基于传统机械硬盘诞生出来的新硬盘）。SSD采用闪存颗粒来存储，HDD采用磁性碟片来存储，混合硬盘（HHD: Hybrid Hard Disk）是把磁性硬盘和闪存集成到一起的一种硬盘。绝大多数硬盘都是固定硬盘，被永久性地密封固定在硬盘驱动器中。内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存（Memory）也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 内存是由内存芯片、电路板、金手指等部分组成的]]></content>
  </entry>
  <entry>
    <title><![CDATA[阅读]]></title>
    <url>%2F2017%2F05%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[如何阅读 [TOC] 怎么阅读 早晨阅读 阅读前运动 阅读动机指定奖励 预期与移开尽可能多的障碍,确保早晨起来时一起都可以直接进行不会分心 公开记录每天的进度 如何更聪明的学习 让学习时间分成一部分一部分的组块,因为注意力集中的时间平均为25分钟到30分钟 创造一个专注学习的空间,理由所身处的环境很大程度上决定着我们行为,更容易投入 学习积极性,在学习之前先问自己,我要学习的是什么,学习内容归结为两类,概念和事实,概念比事实更重要 最佳学习概念的方式,是确保你知道并用自己的话讲述出来,就是用这种方式测试以及更有积极性的学习,还有就是通过距离来说明,再最为重要的地方标记 做笔记对模糊不清的地方进行一点补充,添加一些内容,方便更好的记住概念 最好的学习方式就是靠教别人来学习,因为这是一种积极学习的方式,还能确保自己完全理解课题 正确使用教科书,SQ3R方法: 纵览 提问 阅读 诵读 回顾]]></content>
      <categories>
        <category>习惯</category>
      </categories>
      <tags>
        <tag>habit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟内存]]></title>
    <url>%2F2017%2F05%2F05%2F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[页面文件（pagefile.sys）也称虚拟内存，就是在硬盘上拿出（设定出）一部分空间作为暂不被调用程序或叫“惰性”程序及相关数据的临时存放空间。 1.页面文件（pagefile.sys）也称虚拟内存，就是在硬盘上拿出（设定出）一部分空间作为暂不被调用程序或叫“惰性”程序及相关数据的临时存放空间。 因内存容量总是有限,而实际运行的程序会很多，若都塞在内存中会大量占用有限的内存资源，不利于系统正常、快速、流畅地调用、运行急需的程序及数据。于是系统就开辟出一部分硬盘空间将惰性程序及相关数据暂时存放于此，而让即将被调用的程序或称“活性”程序及数据存留在内存中方便马上调用；而页面文件中暂存的“惰性程序”及数据待CPU需要调用时再与内存交互，如此即为页面文件的工作原理。页面文件像内存一样起到中间暂存、交换作用又是硬盘空间的一部分，所以又叫虚拟内存。 2。 页面文件如同文件夹中常见文件一样，是实实在在存在的文件，只是为安全起见系统将其默认为隐藏文件，显示后一般可在系统盘根目录中见到名为pagefile.sys的文件，它就是页面文件。 3。 要修改页面文件（虚拟内存）的存放位置及大小，对XP而言：可在“我的电脑”上右击选“属性”—“高级”选项卡里的“性能”选项框中—“设置”—“高级”—“虚拟内存”框中—“更改”即来到虚拟内存设置窗口（WIN2000进入类似）。要先确定你的页面文件在哪个驱动器盘符，然后将别的盘符驱动器的页面文件全部禁用，可保留一个页面文件。微软的默认设置是，页面文件最小值应为物理内存的1.5倍，最大值为2-3倍。我的设置建议是同意微软的默认设置，不需要另设它值。若物理内存为1G又觉得1.5倍的最小值设置占硬盘空间较大，最小值可设为1G即物理内存的1倍，以后若出现问题则改回默认设置；最大值默认即可。因页面文件的使用是由小至大、逐渐增加的过程，若最小值范围内可正常运行、交互，系统就不会再增大到最大值的程度。 4。 页面文件最好单独设置在一个盘符里（我的机器就设置到了F盘中），如此能使系统调用虚拟内存中的程序及数据时能更快速、更流畅。还有，变更页面文件的位置之前最好能对相应盘符进行磁盘碎片整理，以使页面文件连续、规律地存放利于快速读取。]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
</search>